/*
 * dlls/advapi32/crypt.c
 */
#include <time.h>
#include <stdlib.h>

#include "windef.h"
#include "winerror.h"
#include "wincrypt.h"
#include "debugtools.h"

DEFAULT_DEBUG_CHANNEL(advapi);

/******************************************************************************
 * CryptAcquireContextA
 * Acquire a crypto provider context handle.
 * 
 * PARAMS
 * phProv: Pointer to HCRYPTPROV for the output.
 * pszContainer: FIXME (unknown)
 * pszProvider: FIXME (unknown)
 * dwProvType: Crypto provider type to get a handle.
 * dwFlags: flags for the operation
 *
 * RETURNS TRUE on success, FALSE on failure.
 */

BOOL WINAPI
CryptAcquireContextA( HCRYPTPROV *phProv, LPCSTR pszContainer,
		      LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags)
{
    FIXME("(%p, %s, %s, %ld, %08lx): stub!\n", phProv, pszContainer,
	  pszProvider, dwProvType, dwFlags);
    return FALSE;
}

/******************************************************************************
 * CryptSetKeyParam
 */
BOOL WINAPI
CryptSetKeyParam( HCRYPTKEY hKey, DWORD dwParam, BYTE *pbData, DWORD dwFlags)
{
    FIXME("(%lx, %lx, %p, %lx): stub!\n", hKey, dwParam, pbData, dwFlags);
    return FALSE;
}


/******************************************************************************
 * CryptGenRandom
 */
BOOL WINAPI
CryptGenRandom (HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer)
{
   DWORD i;

   FIXME("(0x%lx, %ld, %p): stub!\n", hProv, dwLen, pbBuffer);
   /*
    FIXME: Currently this function is just a stub, it is missing functionality in 
           the following (major) ways:
      (1) It makes no use of the passed in HCRYPTPROV handle. (ie. it doesn't
          use a cryptographic service provider (CSP)
      (2) It doesn't use the values in the passed in pbBuffer to further randomize
          its internal seed.
      (3) MSDN mentions that this function produces "cryptographically random"
          data, which is "... far more random than the data generated by the typical
          random number generator such as the one shipped with your C compiler".
          We are currently using the C runtime rand() function. ^_^

      See MSDN documentation for CryptGenRandom for more information.
    */

   if (dwLen <= 0)
      return FALSE; 
  
   srand(time(NULL));
   for (i=0; i<dwLen; i++)
   {
      *pbBuffer = (BYTE)(rand() % 256);
      pbBuffer++;
   }

   return TRUE;
}


/******************************************************************************
 * CryptReleaseContext
 */
BOOL WINAPI
CryptReleaseContext (HCRYPTPROV hProv, DWORD dwFlags)
{
   FIXME("(0x%lx, 0x%lx): stub!\n", hProv, dwFlags);
   return FALSE;
}
