#!/usr/bin/perl -w
#
# Update the dll dependencies in the dlls main Makefile.in.
# Must be run in the dlls/ directory of the Wine tree.
#
# Copyright 2001 Alexandre Julliard
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

use strict;

my $makefiles = `find . -name Makefile.in -print`;

my %imports = ();
my %directories = ();
my %altnames = ();
my %linked_dlls = ();

# list of special dlls that can be switched on or off by configure
my %special_dlls =
(
  "ddraw"    => "XFILES",
  "glu32"    => "GLU32FILES",
  "opengl32" => "OPENGLFILES",
  "x11drv"   => "XFILES"
);

foreach my $i (split(/\s/,$makefiles))
{
    my $module;

    next if $i =~ /\/tests\/Makefile.in/;

    open MAKE,$i;

    $module = undef;
    while (<MAKE>)
    {
        chop;
        # EPP hack to disable this DLL... the MKDLL_SKIP comment must appear
        # at the very top of the Makefile.in
        last if (/^\#\s*MKDLL_SKIP/);

        if (/^MODULE\s*=\s*([a-zA-Z0-9_.]+)/)
        {
            $module = $1;
            $imports{$module} = [ ];
            ($directories{$module} = $i) =~ s/^\.\/(.*)\/[^\/]+$/$1/;
            next;
        }
        if (/^ALTNAMES\s*=\s*(.*)/)
        {
            my @list = split(/\s/,$1);
            $altnames{$module} = \@list;
            next;
        }
        if (/^(DELAYIMPORTS|IMPORTS)\s*=\s*(.*)/)
        {
            my @list = map { /\./ ? $_ : $_ . ".dll"; } split(/\s/,$2);
            push @{$imports{$module}}, @list;
            next;
        }
        if (/^LDIMPORTS\s*=\s*(.*)/)
        {
            my @list = map { /\./ ? $_ : $_ . ".dll"; } split(/\s/,$1);
            $linked_dlls{$module} = \@list;
            next;
        }
    }
    close MAKE;
    push @{$imports{$module}}, "kernel32.dll" unless !defined($module) || @{$imports{$module}} || $module eq "ntdll.dll";
}

open NEWMAKE,">Makefile.in.new" or die "cannot create Makefile.in.new";

################################################################
# makefile header

print NEWMAKE <<EOF;
# Automatically generated by make_dlls; DO NOT EDIT!!

TOPSRCDIR = \@top_srcdir\@
TOPOBJDIR = ..
SRCDIR    = \@srcdir\@
VPATH     = \@srcdir\@

EOF

################################################################
# output special dlls configure definitions

printf NEWMAKE "# special configure-dependent targets\n\n";
my %specials = ();
foreach my $mod (sort keys %special_dlls)
{
    $specials{$special_dlls{$mod}} .= " " . $mod;
}
foreach my $i (sort keys %specials)
{
    printf NEWMAKE "%s =%s\n", $i, $specials{$i};
}
printf NEWMAKE "EXTRADIRS =";
foreach my $i (sort keys %specials) { printf NEWMAKE " \@%s\@", $i; }
printf NEWMAKE "\n\n";


################################################################
# output the subdirs list

print NEWMAKE "# Subdir list\n\nBASEDIRS =";
foreach my $dir (sort values %directories)
{
    next if defined($special_dlls{$dir});  # skip special dlls
    printf NEWMAKE " \\\n\t%s", $dir;
}

printf NEWMAKE "\n\nSUBDIRS = \\\n\t\$(BASEDIRS)";
foreach my $dir (sort keys %special_dlls)
{
    printf NEWMAKE " \\\n\t%s", $dir;
}
printf NEWMAKE <<EOF;


BUILDSUBDIRS = \$(BASEDIRS) \$(EXTRADIRS)

INSTALLSUBDIRS = \$(BUILDSUBDIRS)
EOF

################################################################
# output the all: target

my %targets = ();  # use a hash to get rid of duplicate target names
foreach my $mod (sort keys %directories)
{
    next if defined($special_dlls{$directories{$mod}});  # skip special dlls
    $targets{sprintf("%s\$(DLLEXT)",$mod)} = 1;
    next unless defined $altnames{$mod};
    foreach my $i (sort @{$altnames{$mod}})
    {
        $targets{sprintf("%s\$(DLLEXT)",$i)} = 1;
    }
}
print NEWMAKE <<EOF;

# Main target

\@MAKE_RULES\@

all: \\
	\$(EXTRADIRS:%=%.dll\$(DLLEXT)) \\
EOF
printf NEWMAKE "\t%s\n", join( " \\\n\t", sort keys %targets );


################################################################
# output the lib name -> directory rules

print NEWMAKE <<EOF;

# Map symlink name to the corresponding library

EOF

foreach my $mod (sort keys %directories)
{
    printf NEWMAKE "%s\$(DLLEXT)", $mod;
    if (defined $altnames{$mod})
    {
        my $count = 1;
        foreach my $i (sort @{$altnames{$mod}})
        {
            if (!($count++ % 3)) { printf NEWMAKE " \\\n "; }
            printf NEWMAKE " %s\$(DLLEXT)", $i;
        }
    }
    printf NEWMAKE ": %s/%s\$(DLLEXT)\n", $directories{$mod}, $mod;
    printf NEWMAKE "\t\$(RM) \$@ && \$(LN_S) %s/%s\$(DLLEXT) \$@\n\n", $directories{$mod}, $mod;
}


################################################################
# output the inter-dll dependencies and rules

print NEWMAKE "# Map library name to the corresponding directory\n\n";

foreach my $mod (sort keys %directories)
{
    printf NEWMAKE "%s/%s\$(DLLEXT): %s\n", $directories{$mod}, $mod, $directories{$mod};
}

print NEWMAKE "\n# Install dependencies\n\n";

foreach my $mod (sort keys %directories)
{
    printf NEWMAKE "%s/__install__: %s\$(DLLEXT)\n", $directories{$mod}, $mod;
}

print NEWMAKE "\n# Inter-dll dependencies\n\n";

my @depends = ();
foreach my $mod (sort keys %imports)
{
    next unless @{$imports{$mod}};
    my $count = 0;
    my $dep = sprintf("%s:", $directories{$mod});
    $dep .= " " x (8-length($directories{$mod}));
    foreach my $i (@{$imports{$mod}})
    {
        if ($count++ >= 4)
        {
            $count = 1;
            $dep .= " \\\n" . " " x 9;
        }
        $dep .= sprintf(" %s\$(DLLEXT)", $i);
    }
    foreach my $i (@{$linked_dlls{$mod}})
    {
        if ($count++ >= 4)
        {
            $count = 1;
            $dep .= " \\\n" . " " x 9;
        }
        $dep .= sprintf(" lib%s.\$(LIBEXT)", $i);
    }
    push @depends, $dep . "\n";
}
print NEWMAKE sort @depends;


################################################################
# output the linkable dlls special links

my %linkable_dlls = ();
foreach my $mod (keys %imports)
{
    foreach my $i (@{$linked_dlls{$mod}}) { $linkable_dlls{$i} = 1; }
}

print NEWMAKE "\n# Special targets for dlls that we need to link to\n\n";
printf NEWMAKE "LINKABLE_DLLS = %s\n\n", join( " ", keys %linkable_dlls );

foreach my $mod (keys %linkable_dlls)
{
    printf NEWMAKE "lib%s.\$(LIBEXT): %s/%s\$(DLLEXT)\n", $mod, $directories{$mod}, $mod;
    printf NEWMAKE "\t\$(RM) \$@ && \$(LN_S) %s/%s\$(DLLEXT) \$@\n\n", $directories{$mod}, $mod;
}

print NEWMAKE <<EOF;
uninstall::
	\$(RM) \$(LINKABLE_DLLS:%=\$(libdir)/lib%.\$(LIBEXT))

install::
	\$(RM) \$(LINKABLE_DLLS:%=\$(libdir)/lib%.\$(LIBEXT))
	cd \$(libdir) && if [ "\$(dlldir)" = "\$(libdir)/wine" ]; \\
	then \\
EOF
foreach my $mod (keys %linkable_dlls)
{
    printf NEWMAKE "\t  \$(LN_S) wine/%s\$(DLLEXT) lib%s.\$(LIBEXT); \\\n", $mod, $mod;
}
print NEWMAKE "\telse \\\n";
foreach my $mod (keys %linkable_dlls)
{
    printf NEWMAKE "\t  \$(LN_S) \$(dlldir)/%s\$(DLLEXT) lib%s.\$(LIBEXT); \\\n", $mod, $mod;
}
print NEWMAKE "\tfi\n\n";

################################################################
# makefile trailer

print NEWMAKE <<EOF;
# Misc rules

uninstall::
	-rmdir \$(dlldir)

check test:: \$(BUILDSUBDIRS:%=%/__test__)

crosstest:: \$(BUILDSUBDIRS:%=%/__crosstest__)

checklink:: \$(BUILDSUBDIRS:%=%/__checklink__)

### Dependencies:
EOF

close NEWMAKE;
rename "Makefile.in.new", "Makefile.in";
printf "Successfully updated Makefile.in\n";
