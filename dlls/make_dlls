#!/usr/bin/perl -w
#
# Update the dll dependencies in the dlls main Makefile.in.
# Must be run in the dlls/ directory of the Wine tree.
#
# Copyright 2001 Alexandre Julliard
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

$makefiles = `find . -name Makefile.in -print`;

%imports = ();
%directories = ();
%altnames = ();
%linked_dlls = ();

# list of special dlls that can be switched on or off by configure
%special_dlls =
(
  "ddraw"    => "XFILES",
  "glu32"    => "GLU32FILES",
  "opengl32" => "OPENGLFILES",
  "x11drv"   => "XFILES"
);

foreach $i (split(/\s/,$makefiles))
{
    open MAKE,$i;
    while (<MAKE>)
    {
        chop;
        if (/^MODULE\s*=\s*([a-zA-Z0-9_.]+)/)
        {
            $module = $1;
            ($directories{$module} = $i) =~ s/^\.\/(.*)\/[^\/]+$/$1/;
            next;
        }
        if (/^ALTNAMES\s*=\s*(.*)/)
        {
            my @list = split(/\s/,$1);
            $altnames{$module} = \@list;
            next;
        }
        if (/^IMPORTS\s*=\s*(.*)/)
        {
            my @list = split(/\s/,$1);
            $linked_dlls{$module} = \@list;
            next;
        }
    }
}

foreach $mod (sort keys %directories)
{
    my $dll = $mod;
    $dll =~ s/\.dll$//;
    my $spec = sprintf("%s/%s.spec", $directories{$mod}, $dll);
    open SPEC,$spec or die "cannot open $spec";
    $imports{$mod} = [ ];
    while (<SPEC>)
    {
        if (/^\#?import\s+(-delay\s+)?([a-zA-Z0-9_]+)\.dll/)
        {
            my $imp = $2 . ".dll";
            push @{$imports{$mod}}, $imp;
            next;
        }
        if (/^\#?import\s+(-delay\s+)?([a-zA-Z0-9_.]+)/)
        {
            my $imp = $2;
            $imp .= ".dll" unless ($imp =~ /\./);
            push @{$imports{$mod}}, $imp;
            next;
        }
    }
}

open NEWMAKE,">Makefile.in.new" or die "cannot create Makefile.in.new";

################################################################
# makefile header

print NEWMAKE <<EOF;
# Automatically generated by make_dlls; DO NOT EDIT!!

TOPSRCDIR = \@top_srcdir\@
TOPOBJDIR = ..
SRCDIR    = \@srcdir\@
VPATH     = \@srcdir\@

EOF

################################################################
# output special dlls configure definitions

printf NEWMAKE "# special configure-dependent targets\n\n";
my %specials = ();
foreach $mod (sort keys %special_dlls)
{
    $specials{$special_dlls{$mod}} .= " " . $mod;
}
foreach $i (sort keys %specials)
{
    printf NEWMAKE "%s =%s\n", $i, $specials{$i};
}
printf NEWMAKE "EXTRADIRS =";
foreach $i (sort keys %specials) { printf NEWMAKE " \@%s\@", $i; }
printf NEWMAKE "\n\n";


################################################################
# output the subdirs list

print NEWMAKE <<EOF;
# Subdir list

SUBDIRS = \\
EOF
printf NEWMAKE "\t\$(EXTRADIRS)";
foreach $dir (sort values %directories)
{
    next if defined($special_dlls{$dir});  # skip special dlls
    printf NEWMAKE " \\\n\t%s", $dir;
}
printf NEWMAKE "\n";


################################################################
# output the all: target

my %targets = ();  # use a hash to get rid of duplicate target names
foreach $mod (sort keys %directories)
{
    next if defined($special_dlls{$directories{$mod}});  # skip special dlls
    $targets{sprintf("%s\$(DLLEXT)",$mod)} = 1;
    next unless defined $altnames{$mod};
    foreach $i (sort @{$altnames{$mod}})
    {
        $targets{sprintf("%s\$(DLLEXT)",$i)} = 1;
    }
}
print NEWMAKE <<EOF;

# Main target

\@MAKE_RULES\@

all: \\
	\$(EXTRADIRS:%=%.dll\$(DLLEXT)) \\
EOF
printf NEWMAKE "\t%s\n", join( " \\\n\t", sort keys %targets );


################################################################
# output the lib name -> directory rules

print NEWMAKE <<EOF;

# Map library name to directory

EOF

foreach $mod (sort keys %directories)
{
    printf NEWMAKE "%s\$(DLLEXT)", $mod;
    if (defined $altnames{$mod})
    {
        my $count = 1;
        foreach $i (sort @{$altnames{$mod}})
        {
            if (!($count++ % 3)) { printf NEWMAKE " \\\n "; }
            printf NEWMAKE " %s\$(DLLEXT)", $i;
        }
    }
    printf NEWMAKE ": %s/%s\$(DLLEXT)\n", $directories{$mod}, $mod;
    printf NEWMAKE "\t\$(RM) \$@ && \$(LN_S) %s/%s\$(DLLEXT) \$@\n\n", $directories{$mod}, $mod;
}


################################################################
# output the inter-dll dependencies and rules

print NEWMAKE "# Inter-dll dependencies\n\n";

my @depends = ();
foreach $mod (sort keys %imports)
{
    my $count = 1;
    my $dep = sprintf("%s/%s\$(DLLEXT): dummy", $directories{$mod}, $mod);
    foreach $i (@{$imports{$mod}})
    {
        if ($count++ >= 3)
        {
            $count = 0;
            $dep .= " \\\n ";
        }
        $dep .= sprintf(" %s\$(DLLEXT)", $i);
    }
    foreach $i (@{$linked_dlls{$mod}})
    {
        if ($count++ >= 3)
        {
            $count = 0;
            $dep .= " \\\n ";
        }
        $dep .= sprintf(" lib%s.\$(LIBEXT)", $i);
    }
    $dep .= sprintf("\n\t\@cd %s && \$(MAKE) %s\$(DLLEXT)\n\n",$directories{$mod}, $mod);
    push @depends, $dep;
}
print NEWMAKE sort @depends;


################################################################
# output the linkable dlls special links

%linkable_dlls = ();
foreach $mod (keys %imports)
{
    foreach $i (@{$linked_dlls{$mod}}) { $linkable_dlls{$i} = 1; }
}

print NEWMAKE "# Special targets for dlls that we need to link to\n\n";
foreach $mod (keys %linkable_dlls)
{
    printf NEWMAKE "lib%s.\$(LIBEXT): %s/%s\$(DLLEXT)\n", $mod, $directories{$mod}, $mod;
    printf NEWMAKE "\t\$(RM) \$@ && \$(LN_S) %s/%s\$(DLLEXT) \$@\n\n", $directories{$mod}, $mod;
}

################################################################
# makefile trailer

print NEWMAKE <<EOF;
# Misc rules

\$(SUBDIRS:%=%/__test__): dummy
	\@cd `dirname \$\@` && \$(MAKE) test

\$(SUBDIRS:%=%/__checklink__): dummy
	\@cd `dirname \$\@` && \$(MAKE) checklink

\$(SUBDIRS:%=%/__debug_channels__): dummy
	\@cd `dirname \$\@` && \$(MAKE) debug_channels

install:: \$(SUBDIRS:%=%/__install__)

uninstall:: \$(SUBDIRS:%=%/__uninstall__)
	-rmdir \$(dlldir)

check test:: \$(SUBDIRS:%=%/__test__)

checklink:: \$(SUBDIRS:%=%/__checklink__)

debug_channels:: \$(SUBDIRS:%=%/__debug_channels__)
EOF

close NEWMAKE;
rename "Makefile.in.new", "Makefile.in";
printf "Successfully updated Makefile.in\n";
