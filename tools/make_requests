#! /usr/bin/perl -w
#
# Build the server/trace.c and include/server/request.h files
# from the contents of include/server.h.
#
# Copyright (C) 1998 Alexandre Julliard
#

%formats =
(
    "int"          => "%d",
    "long"         => "%ld",
    "char"         => "%c",
    "unsigned int" => "%08x",
    "void*"        => "%p",
    "time_t"       => "%ld",
    "char[0]"      => "dump_chars",
    "int[0]"       => "dump_ints",
    "void*[0]"     => "dump_ptrs"
);

my @requests = ();
my %replies = ();

open(SERVER,"include/server.h") or die "Can't open include/server.h";
open(TRACE,">server/trace.c") or die "Can't create server/trace.c";
open(REQUESTS,">include/server/request.h") or die "Can't create include/server/request.h";

### Generate the header

print TRACE <<EOF;
/* File generated automatically by $0; DO NOT EDIT!! */

#include <stdio.h>
#include <sys/types.h>
#include <sys/uio.h>
#include "server.h"
#include "thread.h"

static int dump_chars( void *ptr, int len )
{
    fprintf( stderr, "\\\"%.*s\\\"", len, (char *)ptr );
    return len;
}

static int dump_ints( void *ptr, int len )
{
    int i;
    if (!(len /= sizeof(int)))
    {
        fprintf( stderr, "{}" );
        return 0;
    }
    for (i = 0; i < len; i++)
        fprintf( stderr, "%c%d", i ? ',' : '{', *((int *)ptr + i) );
    fprintf( stderr, "}" );
    return len * sizeof(int);
}

static int dump_ptrs( void *ptr, int len )
{
    int i;
    if (!(len /= sizeof(void*)))
    {
        fprintf( stderr, "{}" );
        return 0;
    }
    for (i = 0; i < len; i++)
        fprintf( stderr, "%c%p", i ? ',' : '{', *((void **)ptr + i) );
    fprintf( stderr, "}" );
    return len * sizeof(void*);
}
EOF

### Parse server.h to find request/reply structure definitions

while (<SERVER>)
{
    if (/^struct +(\w+)_request/) { &DO_REQUEST($1); }
    if (/^struct +(\w+)_reply/)   { &DO_REPLY($1); }
}

### Output the dumping function tables

print TRACE "typedef int (*dump_func)( void *req, int len );\n\n";
print TRACE "static const dump_func req_dumpers[REQ_NB_REQUESTS] = {\n";
foreach $req (@requests)
{
    print TRACE "    (dump_func)dump_${req}_request,\n";
}
print TRACE "};\n\n";

print TRACE "static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {\n";
foreach $req (@requests)
{
    print TRACE "    (dump_func)", $replies{$req} ? "dump_${req}_reply,\n" : "0,\n";
}
print TRACE "};\n\n";

print TRACE <<EOF;
static const char * const req_names[REQ_NB_REQUESTS] =
{
EOF
foreach $req (@requests)
{
    print TRACE "    \"$req\",\n";
}

### Output the tracing functions

print TRACE <<EOF;
};

void trace_request( enum request req, void *data, int len, int fd )
{
    int size;
    current->last_req = req;
    fprintf( stderr, "%08x: %s(", (unsigned int)current, req_names[req] );
    size = req_dumpers[req]( data, len );
    if ((len -= size) > 0)
    {
        unsigned char *ptr = (unsigned char *)data + size;
        while (len--) fprintf( stderr, ", %02x", *ptr++ );
    }
    if (fd != -1) fprintf( stderr, " ) fd=%d\\n", fd );
    else fprintf( stderr, " )\\n" );
}

void trace_timeout(void)
{
    fprintf( stderr, "%08x: *timeout*\\n", (unsigned int)current );
}

void trace_kill( int exit_code )
{
    fprintf( stderr,"%08x: *killed* exit_code=%d\\n",
             (unsigned int)current, exit_code );
}

void trace_reply( struct thread *thread, int type, int pass_fd,
                  struct iovec *vec, int veclen )
{
    static char buffer[MAX_MSG_LENGTH];

    if (!thread) return;
    fprintf( stderr, "%08x: %s() = %d",
             (unsigned int)thread, req_names[thread->last_req], type );
    if (veclen)
    {
        char *p = buffer;
        int len;
        for (; veclen; veclen--, vec++)
        {
            memcpy( p, vec->iov_base, vec->iov_len );
            p += vec->iov_len;
        }
	fprintf( stderr, " {" );
        len = p - buffer;
	if (reply_dumpers[thread->last_req])
	    len -= reply_dumpers[thread->last_req]( buffer, len );
        p -= len;
        while (len--) fprintf( stderr, ", %02x", *p++ );
	fprintf( stderr, " }" );
    }
    if (pass_fd != -1) fprintf( stderr, " fd=%d\\n", pass_fd );
    else fprintf( stderr, "\\n" );
}
EOF

### Output the requests list

print REQUESTS <<EOF;
/* File generated automatically by $0; DO NOT EDIT!! */

#ifndef __WINE_SERVER_REQUEST_H
#define __WINE_SERVER_REQUEST_H

enum request
{
EOF

foreach $req (@requests)
{
    print REQUESTS "    REQ_\U$req,\n";
}

print REQUESTS <<EOF;
    REQ_NB_REQUESTS
};

#ifdef WANT_REQUEST_HANDLERS

EOF

foreach $req (@requests) { print REQUESTS "DECL_HANDLER($req);\n"; }

print REQUESTS <<EOF;

static const struct handler {
    void       (*handler)();
    unsigned int min_size;
} req_handlers[REQ_NB_REQUESTS] = {
EOF

foreach $req (@requests)
{
    print REQUESTS "    { (void(*)())req_$req, sizeof(struct ${req}_request) },\n";
}

print REQUESTS <<EOF;
};
#endif  /* WANT_REQUEST_HANDLERS */

#endif  /* __WINE_SERVER_REQUEST_H */
EOF

### Handle a request structure definition

sub DO_REQUEST
{
    my $name = shift;
    my @struct = ();
    while (<SERVER>)
    {
	last if /^};$/;
        next if /^{$/;
	s!/\*.*\*/!!g;
	next if /^\s*$/;
	/ *(\w+\**( +\w+\**)*) +(\w+)(\[0\])?;/ or die "Unrecognized syntax $_";
	my $type = $1 . ($4 || "");
	my $var = $3;
        die "Unrecognized type $type" unless defined($formats{$type});
	push @struct, $type, $var;
    }
    push @requests, $name;
    &DO_DUMP_FUNC( $name . "_request",@struct);
}

### Handle a reply structure definition

sub DO_REPLY
{
    my $name = shift;
    my @struct = ();
    while (<SERVER>)
    {
	last if /^};$/;
        next if /^{$/;
	s!/\*.*\*/!!g;
	next if /^\s*$/;
	/ *(\w+\**( +\w+\**)*) +(\w+)(\[0\])?;/ or die "Unrecognized syntax $_";
	my $type = $1 . ($4 || "");
	my $var = $3;
        die "Unrecognized type $type" unless defined($formats{$type});
	push @struct, $type, $var;
    }
    $replies{$name} = 1;
    &DO_DUMP_FUNC( $name . "_reply" ,@struct);
}

### Generate a dumping function

sub DO_DUMP_FUNC
{
    my $vararg = 0;
    my $name = shift;
    print TRACE "\nstatic int dump_$name( struct $name *req, int len )\n{\n";
    while ($#_ >= 0)
    {
	my $type = shift;
	my $var = shift;
	if ($type =~ /\[0\]$/)  # vararg type?
	{
	    $vararg = 1;
	    print TRACE "    fprintf( stderr, \" $var=\" );\n";
	    print TRACE "    return $formats{$type}( req+1, len - (int)sizeof(*req) ) + sizeof(*req);\n";
	}
	else
	{
	    print TRACE "    fprintf( stderr, \" $var=$formats{$type}";
	    print TRACE "," if ($#_ > 0);
	    print TRACE "\", ";
	    print TRACE "req->$var );\n";
        }
    }
    print TRACE "    return (int)sizeof(*req);\n" unless $vararg;
    print TRACE "}\n";
}
