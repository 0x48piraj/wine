#!/usr/bin/perl -w

# Copyright 1999-2000 Patrik Stridvall

# Note that winapi_check are using heuristics quite heavily.
# So always remember that:
#
# "Heuristics are bug ridden by definition. 
#  If they didn't have bugs, then they'd be algorithms."
#
# In other words, reported bugs are only potential bugs not
# real bugs, so they are called issues rather than bugs.
#

use strict;

BEGIN {
    $0 =~ m%^(.*?/?tools)/winapi_check/winapi_check$%;
    require "$1/winapi/setup.pm";
}

use config qw(
    &file_absolutize &file_normalize
    &file_type &files_filter
    &file_skip &files_skip 
    &get_spec_files
    $current_dir $wine_dir $winapi_dir $winapi_check_dir
);
use modules;
use nativeapi;
use output;
use preprocessor;
use util qw(&is_subset);
use winapi;
use winapi_documentation;
use winapi_function;
use winapi_local;
use winapi_global;
use winapi_options;
use winapi_parser;

my $output = 'output'->new;

my $options = winapi_options->new($output, \@ARGV, $wine_dir);
if(!defined($options)) {
    $output->write("usage: winapi_check [--help] [<files>]\n");

    exit 1;
} elsif($options->help) {
    $options->show_help;
    exit;
}

my $modules = 'modules'->new($options, $output, $wine_dir, $current_dir, \&file_type, "$winapi_check_dir/modules.dat");

my $win16api = 'winapi'->new($options, $output, "win16", "$winapi_check_dir/win16");
my $win32api = 'winapi'->new($options, $output, "win32", "$winapi_check_dir/win32");
my @winapis = ($win16api, $win32api);

if($options->global) {
    'winapi'->read_all_spec_files($modules, $wine_dir, $current_dir, \&file_type, $win16api, $win32api);
} else {
    my @spec_files = $modules->allowed_spec_files($wine_dir, $current_dir);
    'winapi'->read_spec_files($modules, $wine_dir, $current_dir, \@spec_files, $win16api, $win32api);
}

my $nativeapi = 'nativeapi'->new($options, $output, "$winapi_check_dir/nativeapi.dat", "$wine_dir/configure.in", "$wine_dir/include/config.h.in");

my %includes;
{   
    my @files = map {
	s/^.\/(.*)$/$1/;
	$_; 
    } split(/\n/, `find . -name \\*.h`);
    
    foreach my $file (@files) {
	my $file_dir = $file;
	if(!($file_dir =~ s/(.*?)\/[^\/]*$/$1/)) {
	    $file_dir = ".";
	}
   
	$includes{$file} = { name => $file };

	open(IN, "< $file");
	while(<IN>) {
	    if(/^\s*\#\s*include\s*\"(.*?)\"/) {
		my $header = $1;
		if(-e "$file_dir/$header") {
		    $includes{$file}{includes}{"$file_dir/$header"}++;
		} elsif(-e "$file_dir/../$header") { # FIXME: This is not correct
		    $includes{$file}{includes}{"$file_dir/../$header"}++; # FIXME: This is not correct
		} elsif(-e "$wine_dir/include/$header") {
		    $includes{$file}{includes}{"include/$header"}++;
		} else {
		    $output->write("$file: #include \"$header\" is not a local include\n");
		}
	    }
	}
	close(IN);
    }

    my @files2 = ("acconfig.h", "poppack.h", "pshpack1.h", "pshpack2.h", "pshpack4.h", "pshpack8.h",
                  "storage.h", "ver.h");
    foreach my $file2 (@files2) {
	$includes{"include/$file2"}{used}++;
    }    
}

my %declared_functions;

my @c_files = files_skip($options->c_files);
my @h_files = files_skip($options->h_files);

my $progress_output;
my $progress_current=0;
my $progress_max=scalar(@c_files);

if($options->headers) {
    $progress_max += scalar(@h_files);

    foreach my $file (@h_files) {
	my %functions;
	
	$progress_current++;
	if($options->progress) {
	    $output->progress("$file: file $progress_current of $progress_max");
	}
	
	my $found_function = sub {
	    my $function = shift;

	    my $documentation_line = $function->documentation_line;
	    my $documentation = $function->documentation;
	    my $function_line = $function->function_line;
	    my $linkage = $function->linkage;
	    my $return_type = $function->return_type;
	    my $calling_convention = $function->calling_convention;
	    my $internal_name = $function->internal_name;
	    my @argument_types = @{$function->argument_types};
	    my @argument_names = @{$function->argument_names};
	    my @argument_documentations = @{$function->argument_documentations};
	    my $statements = $function->statements;
	    
	    foreach my $winapi (@winapis) {
		my $module = $winapi->function_internal_module($internal_name);
		if(!defined($module)) { next }

		# FIXME: Not correct
		my $external_name = $winapi->function_external_name($internal_name);

		if(defined($external_name)) {
		    $external_name = (split(/\s*&\s*/, $external_name))[0];
		}

		# FIXME: Kludge because of the THUNK variants
		if(!defined($external_name)) {
		    next;
		}

		my $output_function = sub {
		    my $message = shift;

		    $output->write("$file: $module: $return_type ");
		    $output->write("$calling_convention ") if $calling_convention;
		    $output->write("$internal_name(" . join(",", @argument_types) . "): $message\n");
		};
		
		if(!defined($declared_functions{$winapi->name}{$external_name})) {
		    $declared_functions{$winapi->name}{$external_name} = "$file";
		} elsif($options->headers_duplicated) {
		    my $message = "declared more than once";
		    if($file ne $declared_functions{$winapi->name}{$external_name}) {
			$message .= ", first declaration in '" . $declared_functions{$winapi->name}{$external_name} . "'";
		    }
	            &$output_function("$message");
		}

		if($options->headers_misplaced) {
		    if($file =~ /^include\/[^\/]*$/ && $winapi->name eq "win16") {
			&$output_function("declaration misplaced");
		    } elsif($file =~ /^include\/wine\/[^\/]*$/ && $winapi->name eq "win32") {
			&$output_function("declaration misplaced");
		    }
		}
	    }
	};
	
	my $found_preprocessor = sub {
	    my $directive = shift;
	    my $argument = shift;
	};
	
        winapi_parser::parse_c_file $options, $output, $file, $found_function, $found_preprocessor;
    }
}

foreach my $file (@c_files) {
    my %functions = ();

    my $file_module16 = $modules->allowed_modules_in_file("$current_dir/$file");
    my $file_module32 = $modules->allowed_modules_in_file("$current_dir/$file");

    $progress_current++;
    if($options->progress) {
	$output->progress("$file: file $progress_current of $progress_max");
    }

    my $file_dir = $file;
    if(!($file_dir =~ s/(.*?)\/[^\/]*$/$1/)) {
	$file_dir = ".";
    }
   
    my $file_type = file_type($file);

    my $found_function = sub {
	my $function = shift;

	my $internal_name = $function->internal_name;
	$functions{$internal_name} = $function;

	my $documentation_line = $function->documentation_line;
	my $documentation = $function->documentation;
	my $linkage = $function->linkage;
	my $return_type = $function->return_type;
	my $calling_convention = $function->calling_convention;
	my @argument_types = @{$function->argument_types};
	my @argument_names = @{$function->argument_names};
	my @argument_documentations = @{$function->argument_documentations};
	my $statements = $function->statements;

	my $external_name16 = $function->external_name16;
	my $external_name32 = $function->external_name32;

	if($options->global) {
	    $win16api->found_type($return_type) if $options->win16;
	    $win32api->found_type($return_type) if $options->win32;
	    for my $argument (@argument_types) {
		$win16api->found_type($argument) if $options->win16;
		$win32api->found_type($argument) if $options->win32;
	    }

	    $win16api->found_internal_function($internal_name) if $options->win16;
	    $win32api->found_internal_function($internal_name) if $options->win32;
	}

	if($file_type eq "winelib") {
	    my $module16 = $function->module16;
	    my $module32 = $function->module32;

	    foreach my $module ($function->modules) {
		$modules->found_module_in_dir($module, $file_dir);
	    }

	    $output->prefix("$file: " . $function->prefix);

	    if($options->shared) {
		if($win16api->is_shared_internal_function($internal_name) || 
		   $win32api->is_shared_internal_function($internal_name)) 
		{
		    $output->write("is shared between Win16 and Win32\n");
		}
	    }

	    # FIXME: Not correct
	    if(defined($external_name16)) {
		$external_name16 = (split(/\s*&\s*/, $external_name16))[0];
	    }
	    
	    # FIXME: Not correct
	    if(defined($external_name32)) {
		$external_name32 = (split(/\s*&\s*/, $external_name32))[0];
	    }

	    if($options->local && $options->misplaced &&
	       $linkage ne "extern" && defined($statements)) 
	    {
		if($options->win16 && $options->report_module($module16))
		{
		    if($file ne "library/port.c" &&
		       !$nativeapi->is_function($internal_name) &&
		       !is_subset($module16, $file_module16))
		    {
			foreach my $module16 (split(/\s*&\s*/, $module16)) {
			    if(!$win16api->is_function_stub($module16, $internal_name)) {
				$output->write("is misplaced ($module16)\n");
			    }
			}
		    }
		}

		if($options->win32 && $options->report_module($module32))
		{
		    if($file ne "library/port.c" &&
		       !$nativeapi->is_function($internal_name) &&
		       !is_subset($module32, $file_module32))
		    {
			foreach my $module32 (split(/\s*&\s*/, $module32)) {
			    if(!$win32api->is_function_stub($module32, $internal_name)) {
				$output->write("is misplaced ($module32)\n");
			    }
			}
		    }
		}
	    }

	    if($options->local && $options->headers && $options->prototype) {
		if($options->win16 && $options->report_module($module16)) {
		    if(!defined($external_name16) || (!$nativeapi->is_function($external_name16) && 
		       !defined($declared_functions{$win16api->name}{$external_name16})))
		    {
			if(!defined($external_name16) || ($external_name16 !~ /^DllEntryPoint$/ &&
			    $internal_name !~ /^I(?:Malloc|Storage)16_fn/ &&
			    $internal_name !~ /^(?:\Q$module16\E|THUNK|WIN16)_\Q$external_name16\E(?:16)?$/))
			{
			    $output->write("no prototype\n");
			}
		    }
		}

		if($options->win32 && $options->report_module($module32)) {
		    if(!defined($external_name32) || (!$nativeapi->is_function($external_name32) && 						          !defined($declared_functions{$win32api->name}{$external_name32})))
		    {
			if(!defined($external_name32) || ($external_name32 !~ /^Dll(?:
			   Install|CanUnloadNow|GetClassObject|GetVersion|
			   RegisterServer|RegisterServerEx|UnregisterServer)|DriverProc$/x && 
			   $internal_name !~ /^COMCTL32_Str/ &&
			   $internal_name !~ /^(?:\Q$module32\E|wine)_(?:\Q$external_name32\E|\d+)$/))
			{
			    $output->write("no prototype\n");
			}
		    }
		}
	    }

	    if($options->local && $options->argument) {
		if($options->win16 && $options->report_module($module16)) {
		  winapi_local::check_function $options, $output,
		    $return_type, $calling_convention, $external_name16, $internal_name, [@argument_types], $nativeapi, $win16api;
		}	
		if($options->win32 && $options->report_module($module32)) {
		  winapi_local::check_function $options, $output,
		    $return_type, $calling_convention, $external_name32, $internal_name, [@argument_types], $nativeapi, $win32api;
		}
	    }

	    if($options->local && $options->statements) {
		if($options->win16 && $options->report_module($module16)) {
		  winapi_local::check_statements $options, $output, $win16api, \%functions, $function;
		}

		if($options->win32 && $options->report_module($module32)) {
		  winapi_local::check_statements $options, $output, $win32api, \%functions, $function;
		}
	    }

	    if($options->local && $options->documentation &&
	       (defined($module16) || defined($module32)) &&
	       $linkage ne "extern" && defined($statements))
	    {
	        winapi_documentation::check_documentation $options, $output, $win16api, $win32api, $modules, $function;
	    }
	    $output->prefix("");
	}
    };

    my $config = 0;
    my $conditional = 0;
    my $found_include = sub {
	local $_ = shift;
	if(/^\"config\.h\"/) {
	    $config++;
	}
    };
    my $found_conditional = sub {
	local $_ = shift;

	$nativeapi->found_conditional($_);

	if($options->config) {
	    if($file_type ne "application") {
		if(!$nativeapi->is_conditional($_)) {
		    if(/^HAVE_/ && !/^HAVE_(IPX|MESAGL|BUGGY_MESAGL|WINE_CONSTRUCTOR)$/)
		    {
			$output->write("$file: $_ is not declared as a conditional\n");
		    }
		} else {
		    $conditional++;
		    if(!$config) {
			$output->write("$file: conditional $_ used but config.h is not included\n");
		    }
		}
	    }
	}
    };
    my $preprocessor = 'preprocessor'->new($found_include, $found_conditional);
    my $found_preprocessor = sub {
	my $directive = shift;
	my $argument = shift;

	$preprocessor->directive($directive, $argument);

	if($options->config) {
	    if($directive eq "include") {
		my $header;
		my $check_protection;
		my $check_local;
		if($argument =~ /^<(.*?)>$/) {
		   $header = $1;
		   if($file_type ne "application") {
		       $check_protection = 1;
		   } else {
		       $check_protection = 0;
		   }
		   $check_local = 0;
		} elsif($argument =~ /^"(.*?)"$/) {
		   $header = $1;
		   $check_protection = 0;
		   $check_local = 1;
		}

		if($check_protection) {
		    if((-e "$wine_dir/include/$header" || -e "$file_dir/$header")) {
			if($header !~ /^ctype.h$/) {
			    $output->write("$file: #include \<$header\> is a local include\n");
			}
		    }

		    my $macro = uc($header);
		    $macro =~ y/\.\//__/;
		    $macro = "HAVE_" . $macro;
		    
		    if($nativeapi->is_conditional_header($header)) { 
			if(!$preprocessor->is_def($macro)) {
			    if($macro =~ /^HAVE_X11/) {
				# Do nothing X Windows is handled differently
			    } elsif($macro =~ /^HAVE_(.*?)_H$/) {
				if($header ne "alloca.h" && !$preprocessor->is_def("STATFS_DEFINED_BY_$1")) {
				    $output->write("$file: #$directive $argument: is a conditional include, " . 
						   "but is not protected\n");
				}
			    }
			}
		    } elsif($preprocessor->is_def($macro)) {
			$output->write("$file: #$directive $argument: is protected, " .
				       "but is not a conditional include\n");
		    }
		}

		if($check_local) {
		    if(-e "$file_dir/$header") {
			$includes{"$file_dir/$header"}{used}++;
			foreach my $name (keys(%{$includes{"$file_dir/$header"}{includes}})) {
			    $includes{$name}{used}++;
			}
		    } elsif(-e "$file_dir/../$header") { # FIXME: Kludge
			$includes{"$file_dir/../$header"}{used}++; # FIXME: This is not correct
			foreach my $name (keys(%{$includes{"$file_dir/../$header"}{includes}})) { # FIXME: This is not correct
			    $includes{$name}{used}++;
			}
		    } elsif($header eq "controls.h") { # FIXME: Kludge
			$includes{"dlls/user/$header"}{used}++;
			foreach my $name (keys(%{$includes{"dlls/user/$header"}{includes}})) {
			    $includes{$name}{used}++;
			}
		    } elsif(-e "$wine_dir/include/$header") {
			$includes{"include/$header"}{used}++;
			foreach my $name (keys(%{$includes{"include/$header"}{includes}})) {
			    $includes{$name}{used}++;
			}
		    } else {
			$output->write("$file: #include \"$header\" is not a local include\n");
		    }
		}
	    }
	}
    };
  
    winapi_parser::parse_c_file $options, $output, $file, $found_function, $found_preprocessor;
    
    if($options->config_unnessary) {
	if($config && $conditional == 0) {
	    $output->write("$file: includes config.h but do not use any conditionals\n");
	}
    }

    winapi_local::check_file $options, $output, $file, \%functions;
}

$output->hide_progress;

if($options->global) {
    winapi_documentation::report_documentation $options, $output;

    if($options->headers) {
	foreach my $name (sort(keys(%includes))) {
	    if(!$includes{$name}{used}) {
		if($options->include) {
		    $output->write("*.c: $name: include file is never used\n");
		}
	    }
	}
    }

    winapi_global::check $options, $output, $win16api, $nativeapi if $options->win16;
    winapi_global::check $options, $output, $win32api, $nativeapi if $options->win32;

    $modules->global_report;
    $nativeapi->global_report;
}
