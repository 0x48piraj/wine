#!/usr/bin/perl -w

# Copyright 2001 Patrik Stridvall

use strict;

BEGIN {
    $0 =~ m%^(.*?/?tools)/winapi/winapi_fixup$%;
    require "$1/winapi/setup.pm";
}

use config qw(
    &file_type &files_filter
    &file_skip &files_skip
    &file_normalize 
    &get_spec_files
    $current_dir $wine_dir $winapi_dir $winapi_check_dir
);
use output qw($output);
use winapi_fixup_options qw($options);

if($options->progress) {
    $output->enable_progress;
} else {
    $output->disable_progress;
}

use c_parser;
use type;

use winapi_fixup_documentation qw(&fixup_documentation);
use winapi_fixup_editor;
use winapi_fixup_statements qw(&fixup_statements);

my @c_files = $options->c_files;
@c_files = files_skip(@c_files);
@c_files = files_filter("winelib", @c_files);

my $progress_output;
my $progress_current = 0;
my $progress_max = scalar(@c_files);

foreach my $file (@c_files) {
    my $editor = new winapi_fixup_editor($file);

    $progress_current++;
    $output->progress("$file (file $progress_current of $progress_max)");
    $output->prefix("$file:");

    {
	open(IN, "< $file");
	local $/ = undef;
	$_ = <IN>;
	close(IN);
    }
    
    my $parser = new c_parser($file);

    my $found_preprocessor = sub {
	my $begin_line = shift;
	my $begin_column = shift;
	my $preprocessor = shift;

	# $output->write("$begin_line.$begin_column: preprocessor: $preprocessor\n");

	return 1;
    };

    $parser->set_found_preprocessor_callback($found_preprocessor);  

    my $found_comment = sub {
	my $begin_line = shift;
	my $begin_column = shift;
	my $comment = shift;

	# $output->write("$begin_line.$begin_column: comment: $comment\n");

	return 1;
    };

    $parser->set_found_comment_callback($found_comment);  

    my $found_declaration = sub {
	my $begin_line = shift;
	my $begin_column = shift;
	my $end_line = shift;
	my $end_column = shift;
	my $declaration = shift;

	# $output->write("$begin_line.$begin_column-$end_line.$end_column: declaration: \\\n$declaration\n");

	return 1;
    };

    $parser->set_found_declaration_callback($found_declaration);  

    my $function;

    my $found_function = sub {
	$function = shift;
	
	my $name = $function->name;
	my $begin_line = $function->begin_line;
	my $begin_column = $function->begin_column;
	
	$output->progress("$file (file $progress_current of $progress_max): $name");
	$output->prefix("$file:$begin_line: function $name: ");
	# $output->prefix_callback(sub { return $function->prefix; });
	
	if($options->documentation) {
	    # fixup_documentation($function, $editor);
	}
	
	if($options->statements) {
	    fixup_statements($function, $editor);
	}
	
	my $statements = $function->statements;
	if(!defined($statements)) {
	    $function = undef;
	    $output->prefix("$file: ");
	}

	return 0;
    };
    
    $parser->set_found_function_callback($found_function);

    my $found_variable = sub {
	my $begin_line = shift;
	my $begin_column = shift;
	my $linkage = shift;
	my $type = shift;
	my $name = shift;

	# $output->write("$begin_line.$begin_column: $linkage $type $name\n");
	
	return 1;
    };

    $parser->set_found_variable_callback($found_variable);        

    my $line = 1;
    my $column = 0;
    if(!$parser->parse_c_file(\$_, \$line, \$column)) {
	$output->write("can't parse file\n");
    }

    $output->prefix("");

    $editor->flush;
}
