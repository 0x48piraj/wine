#!/usr/bin/perl -w

# Copyright 2001 Patrik Stridvall

use strict;

BEGIN {
    $0 =~ m%^(.*?/?tools)/winapi/winapi_fixup$%;
    require "$1/winapi/setup.pm";
}

use config qw(
    &file_type &files_filter
    &file_skip &files_skip
    &file_normalize 
    &get_spec_files
    $current_dir $wine_dir $winapi_dir $winapi_check_dir
);
use output qw($output);
use winapi_fixup_options qw($options);

use type;
use winapi_function;
use winapi_parser;

use winapi_fixup_documentation qw(&fixup_documentation);
use winapi_fixup_editor;
use winapi_fixup_statements qw(&fixup_statements);

my @c_files = $options->c_files;
@c_files = files_skip(@c_files);
@c_files = files_filter("winelib", @c_files);

my $progress_output;
my $progress_current = 0;
my $progress_max = scalar(@c_files);

foreach my $file (@c_files) {
    my $editor = new winapi_fixup_editor($file);

    $progress_current++;
    if($options->progress) {
	$output->progress("$file (file $progress_current of $progress_max)");
    }

    my $create_function = sub {
	return 'winapi_function'->new;
    };

    my $found_function = sub {
	my $function = shift;

	my $internal_name = $function->internal_name;
	if($options->progress) {
	    $output->progress("$file (file $progress_current of $progress_max): $internal_name");
	}

	$output->prefix_callback(sub { return $function->prefix; });

	if($options->documentation) {
	    fixup_documentation($function, $editor);
	}

	if($options->statements) {
	    fixup_statements($function, $editor);
	}

	$output->prefix("");
    };

    my $create_type = sub {
	return 'type'->new;
    };

    my $found_type = sub {
	my $type = shift;
    };

    my $found_preprocessor = sub {
	my $directive = shift;
	my $argument = shift;
    };

    &winapi_parser::parse_c_file($file, $create_function, $found_function, $create_type, $found_type, $found_preprocessor);

    $editor->flush;
}

